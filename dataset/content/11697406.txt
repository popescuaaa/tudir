A mathematical symbol is a figure or a combination of figures that is used to represent a mathematical object, an action on mathematical objects, a relation between mathematical objects, or for structuring the other symbols that occur in a formula. As formulas are entirely constituted with symbols of various types, many symbols are needed for expressing all mathematics.

The most basic symbols are the decimal digits (0, 1, 2, 3, 4, 5, 6, 7, 8, 9), and the letters of the Latin alphabet. The decimal digits are used for representing numbers through the Hindu–Arabic numeral system. Historically, upper-case letters were used for representing points in geometry, and lower-case letters were used for variables and constants. Letters are used for representing many other sort of mathematical objects. As the number of these sorts has dramatically increased in modern mathematics, the Greek alphabet and some Hebrew letters are also used. In mathematical formulas, the standard typeface is italic type for Latin letters and lower-case Greek letters, and upright type for upper case Greek letters. For having more symbols, other typefaces are also used, mainly boldface 




a
,
A
,
b
,
B

,
…


{\displaystyle \mathbf {a,A,b,B} ,\ldots }

, script typeface 





A
,
B


,
…


{\displaystyle {\mathcal {A,B}},\ldots }

 (the lower-case script face is rarely used because of the possible confusion with the standard face), German fraktur 





a
,
A
,
b
,
B


,
…


{\displaystyle {\mathfrak {a,A,b,B}},\ldots }

, and blackboard bold 





N
,
Z
,
Q
,
R
,
C
,
H
,
F


q




{\displaystyle \mathbb {N,Z,Q,R,C,H,F} _{q}}

 (the other letters are rarely used in this face, or their use is unconventional).

The use of Latin and Greek letters as symbols for denoting mathematical objects is not described in this article. For such uses, see Variable (mathematics) and List of mathematical constants. However, some symbols that are described here have the same shape as the letter from which they are derived, such as 




∏





{\displaystyle \textstyle \prod {}}

 and 




∑





{\displaystyle \textstyle \sum {}}

.

Theses letters alone are not sufficient for the needs of mathematicians, and many other symbols are used. Some take their origin in punctuation marks and diacritics traditionally used in typography; others by deforming letter forms, as in the cases of 



∈


{\displaystyle \in }

 and 



∀


{\displaystyle \forall }

. Others, such as + and =, were specially designed for mathematics.

Normally, entries of a glossary are structured by topics and sorted alphabetically. This is not possible here, as there is no natural order on symbols, and many symbols are used in different parts of mathematics with different meanings, often completely unrelated. Therefore, some arbitrary choices had to be made, which are summarized below.

The article is split into sections that are sorted by an increasing level of technicality. That is, the first sections contain the symbols that are encountered in most mathematical texts, and that are supposed to be known even by beginners. On the other hand, the last sections contain symbols that are specific to some area of mathematics and are ignored outside these areas. However, the long section on brackets has been placed near to the end, although most of its entries are elementary: this makes it easier to search for a symbol entry by scrolling.

Most symbols have multiple meanings that are generally distinguished either by the area of mathematics where they are used or by their syntax, that is, by their position inside a formula and the nature of the other parts of the formula that are close to them.

As readers may not be aware of the area of mathematics to which is related the symbol that they are looking for, the different meanings of a symbol are grouped in the section corresponding to their most common meaning.

When the meaning depends on the syntax, a symbol may have different entries depending on the syntax. For summarizing the syntax in the entry name, the symbol 



◻


{\displaystyle \Box }

 is used for representing the neighboring parts of a formula that contains the symbol. See § Brackets for examples of use.

Most symbols have two printed versions. They can be displayed as Unicode characters, or in LaTeX format. With the Unicode version, using search engines and copy-pasting are easier. On the other hand, the LaTeX rendering is often much better (more aesthetic), and is generally considered a standard in mathematics. Therefore, in this article, the Unicode version of the symbols is used (when possible) for labelling their entry, and the LaTeX version is used in their description. So, for finding how to type a symbol in LaTeX, it suffices to look at the source of the article.

For most symbols, the entry name is the corresponding Unicode symbol. So, for searching the entry of a symbol, it suffices to type or copy the Unicode symbol into the search textbox. Similarly, when possible, the entry name of a symbol is also an anchor, which allows linking easily from another Wikipedia article. When an entry name contains special characters such as [, ], and |, there is also an anchor, but one has to look at the article source to know it.

Finally, when there is an article on the symbol itself (not its mathematical meaning), it is linked to in the entry name.

Several logical symbols are widely used in all mathematics, and are listed here. For symbols that are used only in mathematical logic, or are rarely used, see List of logic symbols.

The blackboard bold typeface is widely used for denoting the basic number systems. These systems are often also denoted by the corresponding uppercase bold letter. A clear advantage of blackboard bold is that these symbols cannot be confused with anything else. This allows using them in any area of mathematics, without having to recall their definition. For example, if one encounters 




R



{\displaystyle \mathbb {R} }

 in combinatorics, one should immediately know that this denotes the real numbers, although combinatorics does not study the real numbers (but it uses them for many proofs).

Many sorts of brackets are used in mathematics. Their meanings depend not only on their shapes, but also on the nature and the arrangement of what is delimited by them, and sometimes what appears between or before them. For this reason, in the entry titles, the symbol □ is used for schematizing the syntax that underlies the meaning.

In this section, the symbols that are listed are used as some sorts of punctuation marks in mathematical reasoning, or as abbreviations of English phrases. They are generally not used inside a formula. Some were used in classical logic for indicating the logical dependence between sentences written in plain English. Except for the first two, they are normally not used in printed mathematical texts since, for readability, it is generally recommended to have at least one word between two formulas. However, they are still used on a black board for indicating relationships between formulas.

This module is always available.  It provides access to the mathematical
functions defined by the C standard.
These functions cannot be used with complex numbers; use the functions of the
same name from the cmath module if you require support for complex
numbers.  The distinction between functions which support complex numbers and
those which donât is made since most users do not want to learn quite as much
mathematics as required to understand complex numbers.  Receiving an exception
instead of a complex result allows earlier detection of the unexpected complex
number used as a parameter, so that the programmer can determine how and why it
was generated in the first place.
The following functions are provided by this module.  Except when explicitly
noted otherwise, all return values are floats.
Return the ceiling of x as a float, the smallest integer value greater than or
equal to x.
Return x with the sign of y.  On a platform that supports
signed zeros, copysign(1.0, -0.0) returns -1.0.
New in version 2.6.
Return the absolute value of x.
Return x factorial.  Raises ValueError if x is not integral or
is negative.
New in version 2.6.
Return the floor of x as a float, the largest integer value less than or equal
to x.
Return fmod(x, y), as defined by the platform C library. Note that the
Python expression x % y may not return the same result.  The intent of the C
standard is that fmod(x, y) be exactly (mathematically; to infinite
precision) equal to x - n*y for some integer n such that the result has
the same sign as x and magnitude less than abs(y).  Pythonâs x % y
returns a result with the sign of y instead, and may not be exactly computable
for float arguments. For example, fmod(-1e-100, 1e100) is -1e-100, but
the result of Pythonâs -1e-100 % 1e100 is 1e100-1e-100, which cannot be
represented exactly as a float, and rounds to the surprising 1e100.  For
this reason, function fmod() is generally preferred when working with
floats, while Pythonâs x % y is preferred when working with integers.
Return the mantissa and exponent of x as the pair (m, e).  m is a float
and e is an integer such that x == m * 2**e exactly. If x is zero,
returns (0.0, 0), otherwise 0.5 <= abs(m) < 1.  This is used to âpick
apartâ the internal representation of a float in a portable way.
Return an accurate floating point sum of values in the iterable.  Avoids
loss of precision by tracking multiple intermediate partial sums:
The algorithmâs accuracy depends on IEEE-754 arithmetic guarantees and the
typical case where the rounding mode is half-even.  On some non-Windows
builds, the underlying C library uses extended precision addition and may
occasionally double-round an intermediate sum causing it to be off in its
least significant bit.
For further discussion and two alternative approaches, see the ASPN cookbook
recipes for accurate floating point summation.
New in version 2.6.
Check if the float x is positive or negative infinity.
New in version 2.6.
Check if the float x is a NaN (not a number).  For more information
on NaNs, see the IEEE 754 standards.
New in version 2.6.
Return x * (2**i).  This is essentially the inverse of function
frexp().
Return the fractional and integer parts of x.  Both results carry the sign
of x and are floats.
Return the Real value x truncated to an
Integral (usually a long integer).  Uses the
__trunc__ method.
New in version 2.6.
Note that frexp() and modf() have a different call/return pattern
than their C equivalents: they take a single argument and return a pair of
values, rather than returning their second return value through an âoutput
parameterâ (there is no such thing in Python).
For the ceil(), floor(), and modf() functions, note that all
floating-point numbers of sufficiently large magnitude are exact integers.
Python floats typically carry no more than 53 bits of precision (the same as the
platform C double type), in which case any float x with abs(x) >= 2**52
necessarily has no fractional bits.
Return e**x.
Return e**x - 1.  For small floats x, the subtraction in
exp(x) - 1 can result in a significant loss of precision; the
expm1() function provides a way to compute this quantity to
full precision:
New in version 2.7.
With one argument, return the natural logarithm of x (to base e).
With two arguments, return the logarithm of x to the given base,
calculated as log(x)/log(base).
Changed in version 2.3: base argument added.
Return the natural logarithm of 1+x (base e). The
result is calculated in a way which is accurate for x near zero.
New in version 2.6.
Return the base-10 logarithm of x.  This is usually more accurate
than log(x, 10).
Return x raised to the power y.  Exceptional cases follow
Annex âFâ of the C99 standard as far as possible.  In particular,
pow(1.0, x) and pow(x, 0.0) always return 1.0, even
when x is a zero or a NaN.  If both x and y are finite,
x is negative, and y is not an integer then pow(x, y)
is undefined, and raises ValueError.
Unlike the built-in ** operator, math.pow() converts both
its arguments to type float.  Use ** or the built-in
pow() function for computing exact integer powers.
Changed in version 2.6: The outcome of 1**nan and nan**0 was undefined.
Return the square root of x.
Return the arc cosine of x, in radians.
Return the arc sine of x, in radians.
Return the arc tangent of x, in radians.
Return atan(y / x), in radians. The result is between -pi and pi.
The vector in the plane from the origin to point (x, y) makes this angle
with the positive X axis. The point of atan2() is that the signs of both
inputs are known to it, so it can compute the correct quadrant for the angle.
For example, atan(1) and atan2(1, 1) are both pi/4, but atan2(-1,
-1) is -3*pi/4.
Return the cosine of x radians.
Return the Euclidean norm, sqrt(x*x + y*y). This is the length of the vector
from the origin to point (x, y).
Return the sine of x radians.
Return the tangent of x radians.
Convert angle x from radians to degrees.
Convert angle x from degrees to radians.
Return the inverse hyperbolic cosine of x.
New in version 2.6.
Return the inverse hyperbolic sine of x.
New in version 2.6.
Return the inverse hyperbolic tangent of x.
New in version 2.6.
Return the hyperbolic cosine of x.
Return the hyperbolic sine of x.
Return the hyperbolic tangent of x.
Return the error function at x.
New in version 2.7.
Return the complementary error function at x.
New in version 2.7.
Return the Gamma function at x.
New in version 2.7.
Return the natural logarithm of the absolute value of the Gamma
function at x.
New in version 2.7.
The mathematical constant Ï = 3.141592â¦, to available precision.
The mathematical constant e = 2.718281â¦, to available precision.
CPython implementation detail: The math module consists mostly of thin wrappers around the platform C
math library functions.  Behavior in exceptional cases follows Annex F of
the C99 standard where appropriate.  The current implementation will raise
ValueError for invalid operations like sqrt(-1.0) or log(0.0)
(where C99 Annex F recommends signaling invalid operation or divide-by-zero),
and OverflowError for results that overflow (for example,
exp(1000.0)).  A NaN will not be returned from any of the functions
above unless one or more of the input arguments was a NaN; in that case,
most functions will return a NaN, but (again following C99 Annex F) there
are some exceptions to this rule, for example pow(float('nan'), 0.0) or
hypot(float('nan'), float('inf')).
Note that Python makes no effort to distinguish signaling NaNs from
quiet NaNs, and behavior for signaling NaNs remains unspecified.
Typical behavior is to treat all NaNs as though they were quiet.
Changed in version 2.6: Behavior in special cases now aims to follow C99 Annex F.  In earlier
versions of Python the behavior in special cases was loosely specified.
See also
Complex number versions of many of these functions.
9.1. numbers â Numeric abstract base classes
9.3. cmath â Mathematical functions for complex numbers
How 
                    many can you do? Timed addition, subtraction, multiplication, 
                    and division problems for basic math practice.
                     
 
Contact us | Advertising & Sponsorship | Partnership | Link to us

© 2000-2005 Math.com. All rights reserved.     Legal 
        Notices.     Please read our Privacy 
        Policy.
  
 matma / Getty Images

In mathematics, symbols that have certain meanings in the English language can mean very specialized and different things. For example, consider the following expression:


3!


No, we did not use the exclamation point to show that we’re excited about three, and we shouldn’t read the last sentence with emphasis. In mathematics, the expression 3! is read as "three factorial" and is really a shorthand way to denote the multiplication of several consecutive whole numbers.


Since there are many places throughout mathematics and statistics where we need to multiply numbers together, the factorial is quite useful. Some of the main places where it shows up are combinatorics and probability calculus.


The definition of the factorial is that for any positive whole number n, the factorial:


n! = n x (n -1) x (n - 2) x . . . x 2 x 1


First we will look at a few examples of the factorial with small values of n:


As we can see the factorial gets very large very quickly. Something that may seem small, such as 20! actually has 19 digits.


Factorials are easy to compute, but they can be somewhat tedious to calculate. Fortunately, many calculators have a factorial key (look for the ! symbol). This function of the calculator will automate the multiplications.


One other value of the factorial and one for which the standard definition above does not hold is that of zero factorial. If we follow the formula, then we would not arrive at any value for 0!. There are no positive whole numbers less than 0. For several reasons, it is appropriate to define 0! = 1. The factorial for this value shows up particularly in the formulas for combinations and permutations.


When dealing with calculations, it is important to think before we press the factorial key on our calculator. To calculate an expression such as 100!/98! there are a couple of different ways of going about this.


One way is to use a calculator to find both 100! and 98!, then divide one by the other. Although this is a direct way to calculate, it has some difficulties associated with it. Some calculators cannot handle expressions as large as 100! = 9.33262154 x 10157. (The expression 10157 is a scientific notation that means that we multiply by 1 followed by 157 zeros.) Not only is this number massive, but it is also only an estimate to the real value of 100!


Another way to simplify an expression with factorials like the one seen here does not require a calculator at all. The way to approach this problem is to recognize that we can rewrite 100! not as 100 x 99 x 98 x 97 x . . . x 2 x 1, but instead as 100 x 99 x 98! The expression 100!/98! now becomes (100 x 99 x 98!)/98! = 100 x 99 = 9900.

Actively scan device characteristics for identification. Use precise geolocation data. Store and/or access information on a device. Select personalised content. Create a personalised content profile. Measure ad performance. Select basic ads. Create a personalised ads profile. Select personalised ads. Apply market research to generate audience insights. Measure content performance. Develop and improve products.
List of Partners (vendors)

